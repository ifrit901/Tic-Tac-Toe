package trashtalkintictactoe;

/**
 * This is a Tic Tac Toe player that talks trash to
 * you while you play. Its smart enough to win or 
 * at least tie.
 * 
 * @author craig
 * September 2021
 * Written while working on ambulances at Acadian Ambulance.
 */
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
public class TrashTalkinTicTacToe extends JFrame {

	// Labels to go in the game squares
	JLabel label1, label2, label3, label4, 
	          label5, label6, label7, label8, label9;
	JLabel gameVoice; 			// So the computer can speak to user			
	JLabel [] labelArray;			// To hold the squares
	JLabel [] winningArray; 		// To hold the winning labels
	boolean playerWins = false;		// Booleans to flag who wins or ties
	boolean computerWins = false; 		//                "
	boolean winnerExists = false; 		//                "
	boolean tieExists = false; 		//           	  " 
	boolean gameStarted = false; 		// To flag newGame method  	  
	int bestLabel  = 9; 			// To identify the best move for the computer
	JButton xButton, oButton,  		// Buttons
		newGameButton;		//	  "
	String player, computer; 		// Holds the opponnents X's or O's
	String linePlacement;			// For direction of the winning line
	GameVoices startPhrase;		// gameVoice for player choice
	GameVoices labelPhrase;		// gameVoice for hovering over squares
	GameVoices choicePhrase;		// gameVoice for player making decision
	JPanel gridPanel;			// To hold the squares
	JPanel westPanel;			// To hold the buttons
	JPanel xButtonPanel;			// The X button
	JPanel oButtonPanel; 			// The O button

	/**
	 * Constructor.
	 */
	public TrashTalkinTicTacToe() {
		// Frame details
		setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		setLocation(400, 145);
		setTitle("Trash Talkin' Tic Tac Toe");

		// To hold and initialize the squares 
		labelArray = new JLabel [9]; 	
		for (int i = 0; i < 9; i++) {
			labelArray[i] = new JLabel();
		}
		
		// Add MouseListeners, fonts and borders to the squares
		for (JLabel label : labelArray)  {
			label.addMouseListener(new LabelListener());
			label.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY));
			setLabelFont(label);
		}

		// Special array holding the three winning squares
		winningArray = new JLabel[3];

		// North panel is the game voice label that speaks to player
		gameVoice = new JLabel("Another victim...choose a side");
		setLabelFont(gameVoice);
		gameVoice.setBorder(BorderFactory.createLineBorder(Color.LIGHT_GRAY));

		// Objects for game voice variations 
		startPhrase = new GameVoices();
		labelPhrase = new GameVoices();
		choicePhrase = new GameVoices();

		// Center panel holding game squares
		gridPanel = new JPanel();
		gridPanel.setLayout(new GridLayout(3, 3));
		gridPanel.setPreferredSize(new Dimension(500, 500));
		for(int i = 0; i < 9; i++) {
			gridPanel.add(labelArray[i]);
		}

		// X button initialization
		xButton = new JButton("X");
		xButton.addActionListener(new PlayerButtonListener());
		setButtonFont(xButton);
		xButtonPanel = new JPanel();
		xButtonPanel.add(xButton);

		// O button initialization
		oButton = new JButton("O");
		oButton.addActionListener(new PlayerButtonListener());
		setButtonFont(oButton);
		oButtonPanel = new JPanel();
		oButtonPanel.add(oButton);

		// West panel holds the X and O buttons
		westPanel = new JPanel();
		westPanel.setLayout(new GridLayout(2, 1));
		westPanel.add(xButton);
		westPanel.add(oButton);

		// South panel holds the new game/reset button
		newGameButton = new JButton("New Game");
		setButtonFont(newGameButton);
		newGameButton.addMouseListener(new newGameButtonListener());

		// Add and pack the panels 
		add(gridPanel, BorderLayout.CENTER);
		add(gameVoice, BorderLayout.NORTH);
		add(westPanel, BorderLayout.WEST);
		add(newGameButton, BorderLayout.SOUTH);
		pack();
		setVisible(true);
	}
	
	/**
	 * The PlayerButtonListener is a private inner class handling 
	 * the events generated by the X and O buttons.
	 */
	private class PlayerButtonListener implements ActionListener {
		@Override
		public void actionPerformed(ActionEvent e) {

			// Player chooses X or O
			if (e.getSource() == xButton) {
				player = "X";
				computer = "O";
				xButton.setEnabled(false);
				oButton.setEnabled(false);
				gameStarted = true;
				gameVoice.setText(startPhrase.getPlayerChoiceVoice());
			} else if (e.getSource() == oButton) {
				player = "O";
				computer = "X";
				xButton.setEnabled(false);
				oButton.setEnabled(false);
				gameStarted = true;
				gameVoice.setText(startPhrase.getPlayerChoiceVoice());
			}
		} 
	}

	/**
	 * The LabelListener is a mouse listener that responds to player
	 * choices in the labels.
	 */
	private class LabelListener implements MouseListener {
		/*
		The mousePressed method handles the game logic after 
		the player has made a choice. The square is set with 
		the player's move. The computer then analyzes this 
		move and makes either an aggressive or defensive
		move. Flags are set in place to stop the game state
		if a win or tie is reached after each move.
		*/
		@Override
		public void mousePressed(MouseEvent e) {
			//if (player == null) return;
			if (gameStarted) {
				if (e.getSource() == labelArray[0]) {
					setPlayerMove(labelArray, 0);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				} else if (e.getSource() == labelArray[1]) {
					setPlayerMove(labelArray, 1);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[2]) {
					setPlayerMove(labelArray, 2);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}	
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[3]) {
					setPlayerMove(labelArray, 3);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}	
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[4]) {
					setPlayerMove(labelArray, 4);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}	
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[5]) {
					setPlayerMove(labelArray, 5);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[6]) {
					setPlayerMove(labelArray, 6);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[7]) {
					setPlayerMove(labelArray, 7);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}else if (e.getSource() == labelArray[8]) {
					setPlayerMove(labelArray, 8);
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
						return;
					}
					gameVoice.setText(choicePhrase.getLabelChoiceVoice());
					setComputerMove();
					setWinner();	
					setTie();
					if (winnerExists || tieExists) {
						gameStarted = false;
					}
				}	
			}
		}
		@Override 
		public void mouseReleased(MouseEvent e) {
		}
		@Override
		public void mouseClicked(MouseEvent e) {
		}
		/*
		The mouse entered method handles events generated 
		by the player's cursor entering a label area. A trash talkin'
		phrase is set in the gameVoice label.
		*/
		@Override
		public void mouseEntered(MouseEvent e) {
			if(gameStarted) {
				if (e.getSource() == labelArray[0] || 
				    e.getSource() == labelArray[1] ||
				    e.getSource() == labelArray[2] ||
				    e.getSource() == labelArray[3] || 
				    e.getSource() == labelArray[4] ||
				    e.getSource() == labelArray[5] ||
				    e.getSource() == labelArray[6] ||
				    e.getSource() == labelArray[7] || 
				    e.getSource() == labelArray[8]) {	
					gameVoice.setText
					(labelPhrase.getLabelHoverChoiceVoice());	
				}
			}
			
		}
		@Override
		public void mouseExited(MouseEvent e) {
		}
		
	}
	
	/**
	 * The setPlayerMove method accepts label and String parameters 
	 * to determine what character to add to a square.
	 * @param labels
	 * @param num 
	 */
	public void setPlayerMove(JLabel [] labels, int num) {
		setMoveFont(labels[num], player);
	}

	/**
	 * The setComputerMove method tests the state of the 
	 * game squares and determines the best move.
	 */
	public void setComputerMove() {
		if (findTheBestMove() < 9) {
			setMoveFont(labelArray[findTheBestMove()], computer);
		}
	}

	/**
	 * The findTheBestMove method tests the current status
	 * of the label array to find the best move for the computer.
	 * @return The subscript of the label to place an aggressive or 
	 * 	  defensive move in.
	 */
	public int findTheBestMove() {
		/*
		Initially the computer needs to try to win. The initial 
		statements handle aggressive moves. Then 
		if it can't, it should find the best blocking move.
		*/ 

		// First, all rows passing through the middle are checked 
		// (Diagonals)
		if (labelArray[4].getText().equals(computer) &&
		    labelArray[0].getText().equals(computer) && 
		    labelArray[8].getText().isEmpty()) {
			bestLabel = 8;
		} else if (labelArray[4].getText().equals(computer) &&
		              labelArray[1].getText().equals(computer)&& 
		              labelArray[7].getText().isEmpty()) {
			bestLabel = 7;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[2].getText().equals(computer)&& 
		             labelArray[6].getText().isEmpty()) {
			bestLabel = 6;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[3].getText().equals(computer)&& 
		             labelArray[5].getText().isEmpty()) {
			bestLabel = 5;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[5].getText().equals(computer)&& 
		             labelArray[3].getText().isEmpty()) {
			bestLabel = 3;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[6].getText().equals(computer)&& 
		             labelArray[2].getText().isEmpty()) {
			bestLabel = 2;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[7].getText().equals(computer)&& 
		             labelArray[1].getText().isEmpty()) {
			bestLabel = 1;
		}else if (labelArray[4].getText().equals(computer) &&
		             labelArray[8].getText().equals(computer)&& 
		             labelArray[0].getText().isEmpty()) { 
			bestLabel = 0;
		}

		// The rest of the statements handle the cases where
		// the player has chosen a different strategy than 
		// choosing the middle square.
		// (Horizontal end spaces)
		else if (labelArray[0].getText().equals(computer) && 
		           labelArray[1].getText().equals(computer) &&
		           labelArray[2].getText().isEmpty()) {
			bestLabel = 2;	
		} else if (labelArray[1].getText().equals(computer) && 
		              labelArray[2].getText().equals(computer)&&
		              labelArray[0].getText().isEmpty()) {
			bestLabel = 0;			
		}else if (labelArray[6].getText().equals(computer) && 
		             labelArray[7].getText().equals(computer)&&
		             labelArray[8].getText().isEmpty()) {
			bestLabel = 8;		
		}else if (labelArray[7].getText().equals(computer) && 
		             labelArray[8].getText().equals(computer)&&
		             labelArray[6].getText().isEmpty()) {
			bestLabel = 6;		
		}
		// (Horizontal middles)
		else if (labelArray[3].getText().equals(computer) && 
		           labelArray[5].getText().equals(computer)&&
		           labelArray[4].getText().isEmpty()) {
			bestLabel = 4;
		} else if (labelArray[0].getText().equals(computer) && 
		           labelArray[2].getText().equals(computer)&&
		           labelArray[1].getText().isEmpty()) {
			bestLabel = 1;
		}else if (labelArray[6].getText().equals(computer) && 
		             labelArray[8].getText().equals(computer)&&
		             labelArray[7].getText().isEmpty()) {
			bestLabel = 7;
		}
		// (Vertical end spaces)
		// Always put the choices that pass through the 
		// middle first
		else if (labelArray[1].getText().equals(computer) && 
		             labelArray[4].getText().equals(computer)&&
		             labelArray[7].getText().isEmpty()) {
			bestLabel = 7;		
		}else if (labelArray[4].getText().equals(computer) && 
		             labelArray[7].getText().equals(computer)&&
		             labelArray[1].getText().isEmpty()) {
			bestLabel = 1;		
		}
		else if (labelArray[0].getText().equals(computer) && 
		           labelArray[3].getText().equals(computer)&&
		           labelArray[6].getText().isEmpty()) {
			bestLabel = 6;		
		}else if (labelArray[6].getText().equals(computer) && 
		             labelArray[3].getText().equals(computer)&&
		             labelArray[0].getText().isEmpty()) {
			bestLabel = 0;		
		}else if (labelArray[2].getText().equals(computer) && 
		             labelArray[5].getText().equals(computer)&&
		             labelArray[8].getText().isEmpty()) {
			bestLabel = 8;		
		}else if (labelArray[8].getText().equals(computer) && 
		             labelArray[5].getText().equals(computer)&&
		             labelArray[2].getText().isEmpty()) {
			bestLabel = 2;		
		}
		// (Vertical middles)
		else if (labelArray[1].getText().equals(computer) && 
		             labelArray[7].getText().equals(computer)&&
		             labelArray[4].getText().isEmpty()) {
			bestLabel = 4;		
		}
		else if (labelArray[0].getText().equals(computer) && 
		           labelArray[6].getText().equals(computer)&&
		           labelArray[3].getText().isEmpty()) {
			bestLabel = 3;		
		}else if (labelArray[8].getText().equals(computer) && 
		             labelArray[2].getText().equals(computer)&&
		             labelArray[5].getText().isEmpty()) {
			bestLabel = 5;		
		}

		/////////////////////////////////////////////////////////////////////////
		/*
		Defensive moves.
		*/

		// The first several if statements handle the cases that 
		// the player has chosen the middle square as a tactical
		// advantage and is one move away from winning.
		// (Diagonals)
		  else if (labelArray[4].getText().equals(player) &&
		    labelArray[0].getText().equals(player) && 
		    labelArray[8].getText().isEmpty()) {
			bestLabel = 8;
		} else if (labelArray[4].getText().equals(player) &&
		              labelArray[1].getText().equals(player)&& 
		              labelArray[7].getText().isEmpty()) {
			bestLabel = 7;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[2].getText().equals(player)&& 
		             labelArray[6].getText().isEmpty()) {
			bestLabel = 6;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[3].getText().equals(player)&& 
		             labelArray[5].getText().isEmpty()) {
			bestLabel = 5;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[5].getText().equals(player)&& 
		             labelArray[3].getText().isEmpty()) {
			bestLabel = 3;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[6].getText().equals(player)&& 
		             labelArray[2].getText().isEmpty()) {
			bestLabel = 2;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[7].getText().equals(player)&& 
		             labelArray[1].getText().isEmpty()) {
			bestLabel = 1;
		}else if (labelArray[4].getText().equals(player) &&
		             labelArray[8].getText().equals(player)&& 
		             labelArray[0].getText().isEmpty()) {
			bestLabel = 0;
		}
		// The rest of the statements handle the cases where
		// the player has chosen a different strategy than 
		// choosing the middle square.
		// (Horizontal end spaces)
		  else if (labelArray[0].getText().equals(player) && 
		           labelArray[1].getText().equals(player) &&
		           labelArray[2].getText().isEmpty()) {
			bestLabel = 2;	
		} else if (labelArray[1].getText().equals(player) && 
		              labelArray[2].getText().equals(player)&&
		              labelArray[0].getText().isEmpty()) {
			bestLabel = 0;			
		} else if (labelArray[6].getText().equals(player) && 
		             labelArray[7].getText().equals(player)&&
		             labelArray[8].getText().isEmpty()) {
			bestLabel = 8;		
		} else if (labelArray[7].getText().equals(player) && 
		             labelArray[8].getText().equals(player)&&
		             labelArray[6].getText().isEmpty()) {
			bestLabel = 6;		
		}
		// (Horizontal middles)
		   else if (labelArray[3].getText().equals(player) && 
		           labelArray[5].getText().equals(player)&&
		           labelArray[4].getText().isEmpty()) {
			bestLabel = 4;
		} else if (labelArray[0].getText().equals(player) && 
		           labelArray[2].getText().equals(player)&&
		           labelArray[1].getText().isEmpty()) {
			bestLabel = 1;
		} else if (labelArray[6].getText().equals(player) && 
		             labelArray[8].getText().equals(player)&&
		             labelArray[7].getText().isEmpty()) {
			bestLabel = 7;
		}
		// (Vertical end spaces)
		// Always put the choices that pass through the 
		// middle first
		   else if (labelArray[1].getText().equals(player) && 
		             labelArray[4].getText().equals(player)&&
		             labelArray[7].getText().isEmpty()) {
			bestLabel = 7;		
		} else if (labelArray[4].getText().equals(player) && 
		             labelArray[7].getText().equals(player)&&
		             labelArray[1].getText().isEmpty()) {
			bestLabel = 1;		
		}
		   else if (labelArray[0].getText().equals(player) && 
		           labelArray[3].getText().equals(player)&&
		           labelArray[6].getText().isEmpty()) {
			bestLabel = 6;		
		} else if (labelArray[6].getText().equals(player) && 
		             labelArray[3].getText().equals(player)&&
		             labelArray[0].getText().isEmpty()) {
			bestLabel = 0;		
		} else if (labelArray[2].getText().equals(player) && 
		             labelArray[5].getText().equals(player)&&
		             labelArray[8].getText().isEmpty()) {
			bestLabel = 8;		
		} else if (labelArray[8].getText().equals(player) && 
		             labelArray[5].getText().equals(player)&&
		             labelArray[2].getText().isEmpty()) {
			bestLabel = 2;		
		}
		// (Vertical middles)
		   else if (labelArray[1].getText().equals(player) && 
		             labelArray[7].getText().equals(player)&&
		             labelArray[4].getText().isEmpty()) {
			bestLabel = 4;		
		} else if (labelArray[0].getText().equals(player) && 
		              labelArray[6].getText().equals(player)&&
		              labelArray[3].getText().isEmpty()) {
			bestLabel = 3;		
		} else if (labelArray[8].getText().equals(player) && 
		             labelArray[2].getText().equals(player)&&
		             labelArray[5].getText().isEmpty()) {
			bestLabel = 5;		
		}
		// Take the middle square if not already chosen
		   else if (labelArray[4].getText().isEmpty()) {;
			bestLabel = 4;
		// Add moves on the diagonals if nothing else is better
		} else if (labelArray[0].getText().isEmpty()) {
			bestLabel = 0;
		} else if (labelArray[2].getText().isEmpty()) {
			bestLabel = 2;
		} else if (labelArray[6].getText().isEmpty()) {
			bestLabel = 6; 
		} else if (labelArray[8].getText().isEmpty()) {
			bestLabel = 8;
		}
		// Add moves to the outer middle squares if nothing 
		// else is better
		  else if (labelArray[1].getText().isEmpty()) {
			bestLabel = 1;
		} else if (labelArray[3].getText().isEmpty()) {
			bestLabel = 3;
		} else if (labelArray[5].getText().isEmpty()) {
			bestLabel = 5;
		} else if (labelArray[7].getText().isEmpty()) {
			bestLabel = 7;
		}
		return bestLabel;
	}

	/**
	 * The checkForWinner method makes sure the game isn't over 
	 * before checking for a next best move.
	 * @param array The array of labels.
	 * @return winnerExists The flag for when the player or computer has won.
	 */
	public boolean checkForWinner(JLabel [] array) {
		// (Player wins)
		// Rows
		// (make sure the player has chosen a character first)
		if (!player.equals("")) {
			if (labelArray[0].getText().equals(player) && 
			    labelArray[1].getText().equals(player) &&
			    labelArray[2].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} else if (labelArray[3].getText().equals(player) && 
				      labelArray[4].getText().equals(player) &&
				      labelArray[5].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} else if (labelArray[6].getText().equals(player) && 
				     labelArray[7].getText().equals(player) &&
				     labelArray[8].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} 
			// Columns
			  else if (labelArray[0].getText().equals(player) && 
				     labelArray[3].getText().equals(player) &&
				     labelArray[6].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} else if (labelArray[1].getText().equals(player) && 
				     labelArray[4].getText().equals(player) &&
				     labelArray[7].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} else if (labelArray[2].getText().equals(player) && 
				     labelArray[5].getText().equals(player) &&
				     labelArray[8].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} 
			// Diagonals
			   else if (labelArray[0].getText().equals(player) && 
				   labelArray[4].getText().equals(player) &&
				   labelArray[8].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			} else if (labelArray[2].getText().equals(player) && 
				     labelArray[4].getText().equals(player) &&
				     labelArray[6].getText().equals(player)) {
				playerWins = true;
				winnerExists = true;
			}
			// (Computer wins)
			// Horizontals
			  else if (labelArray[0].getText().equals(computer) && 
				     labelArray[1].getText().equals(computer) &&
				     labelArray[2].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} else if (labelArray[3].getText().equals(computer) && 
				      labelArray[4].getText().equals(computer) &&
				      labelArray[5].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} else if (labelArray[6].getText().equals(computer) && 
				     labelArray[7].getText().equals(computer) &&
				     labelArray[8].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} 
			// Verticals
			  else if (labelArray[0].getText().equals(computer) && 
				     labelArray[3].getText().equals(computer) &&
				     labelArray[6].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} else if (labelArray[1].getText().equals(computer) && 
				     labelArray[4].getText().equals(computer) &&
				     labelArray[7].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} else if (labelArray[2].getText().equals(computer) && 
				     labelArray[5].getText().equals(computer) &&
				     labelArray[8].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} 
			// Diagonals
			   else if (labelArray[0].getText().equals(computer) && 
				   labelArray[4].getText().equals(computer) &&
				   labelArray[8].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			} else if (labelArray[2].getText().equals(computer) && 
				     labelArray[4].getText().equals(computer) &&
				     labelArray[6].getText().equals(computer)) {
				computerWins = true;
				winnerExists = true;
			}
			if (winnerExists) {
				for (JLabel label : labelArray) {
					label.setEnabled(false);
				}
			}
		}
		return winnerExists;
	}
	
	/**
	 * The setWinner method checks for a positive winner
	 * or a tie and sets the gameVoice label to an ending phrase.
	 */
	public void setWinner() {
		if (checkForWinner(labelArray) && playerWins) {
			gameVoice.setText(player + " Wins!");
		} else if (checkForWinner(labelArray) && computerWins) {
			gameVoice.setText(computer + " Wins!");
		} 
		
	}

	/**
	 * The checkForTie method checks to see if all the labels are filled
	 * and that there are no winners. 
	 * @param labels The JLabel array of game squares.
	 * @return tieExists Whether there is a tie or not.
	 */
	public boolean checkForTie(JLabel [] labels) {
		int counter = 0;

		// Count the number of squares that are filled
		for(JLabel label : labels) {
			if(!label.getText().isEmpty()) counter++;
		}
		if (counter == 9) tieExists = true;
		
		return tieExists;
	}

	/**
	 * The setTie method sets the gameVoice label in the event
	 * of a tie and disables the labels so that no more moves 
	 * can be entered.
	 */
	public void setTie() {
		if(checkForTie(labelArray)) {
			gameVoice.setText("It's a Tie!");

			// Disable the labels 
			for (JLabel label : labelArray) {
				label.setEnabled(false);
			}
		}
	}
	
	/**
	 * The setMoveFont method sets the font, weight, 
	 * alignment, and size of the character in the square for 
	 * player and computer moves.
	 * @param label
	 * @param moveMaker
	 */
	public void setMoveFont(JLabel label, String moveMaker) {
		label.setText(moveMaker);
		label.setFont(new Font("Sans Serif", Font.BOLD, 60));
		label.setHorizontalAlignment
			(SwingConstants.CENTER);
	}

	/**
	 * The setLabelFont method styles the characters for 
	 * the labels.
	 * @param label 
	 */
	private void setLabelFont(JLabel label) {
		label.setHorizontalAlignment(SwingConstants.CENTER);
		label.setFont(new Font("Sans Serif", Font.BOLD, 30));
	}

	/**
	 * The setButtonFont method styles the X and O buttons.
	 * @param button
	 */
	private void setButtonFont(JButton button) {
		button.setHorizontalAlignment(SwingConstants.CENTER);
		button.setFont(new Font("Sans Serif", Font.BOLD, 40));
	}

	/**
	 * Private inner class to hold the event generated by 
	 * the new game button.
	 */
	private class newGameButtonListener implements MouseListener {
		@Override
		public void mousePressed(MouseEvent e){
			if (e.getSource() == newGameButton) {
				// Clear all the labels
				for(JLabel label : labelArray) {
					label.setText("");
					label.setEnabled(true);
				}

				// Reset the gameVoice label
				gameVoice.setText("Pick a Side!");

				// Reset the player's string values
				player = "";
				computer = "";

				// Reset the booleans
				playerWins = false;
				computerWins = false;
				winnerExists = false;
				tieExists = false;
				gameStarted = false;

				// Reset the player buttons
				xButton.setEnabled(true);
				oButton.setEnabled(true);
			}
		}
		@Override
		public void mouseClicked(MouseEvent e) {
		}
		@Override
		public void mouseEntered(MouseEvent e) {
		}
		@Override 
		public void mouseExited(MouseEvent e) {
		}
		@Override 
		public void mouseReleased(MouseEvent e) {
		}
	}
		
	/**
	 * The main method creates an instance of the class,
	 * causing its window to be displayed.
	 */
	public static void main(String[]args) {
		new TrashTalkinTicTacToe();
	} 
}
